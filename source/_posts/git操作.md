---
title: git操作总结
date: {{ date }}
tags: git
cover: https://ppoffice.github.io/hexo-theme-icarus/gallery/covers/vector_landscape_3.svg
excerpt: git操作总结
toc: true
---
## 合并

### merge

在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点

<img src="/images/image-20220705190648442.png" alt="image-20220705190648442" style="zoom:67%;" />

执行`git merge bugFix`

<img src="/images/image-20220705190703220.png" alt="image-20220705190703220" style="zoom:67%;" />

首先，`main` 现在指向了一个拥有两个父节点的提交记录。假如从 `main` 开始沿着箭头向上看，在到达起点的路上会经过所有的提交记录。这意味着 `main` 包含了对代码库的所有修改.

但是对于bugFix分支而言，它还没有包含最新代码，此时可以执行：

```shell
git checkout bugFix
git merge main
```

因为 `main` 继承自 `bugFix`，Git 什么都不用做，只是简单地把 `bugFix` 移动到 `main` 所指向的那个提交记录。

<img src="/images/image-20220705190941172.png" alt="image-20220705190941172" style="zoom:67%;" />

### rebase

Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。

Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。

举例说明一下：我们想要把 bugFix 分支里的工作直接移到 main 分支上。移动以后会使得两个分支的功能看起来像是按顺序开发，但实际上它们是并行开发的。

<img src="/images/image-20220705191051607.png" alt="image-20220705191051607" style="zoom: 67%;" />

我们执行如下命令：

```shell
git rebase main
```

<img src="/images/image-20220705191205457.png" alt="image-20220705191205457" style="zoom:67%;" />

现在 bugFix 分支上的工作在 main 的最顶端，同时我们也得到了一个更线性的提交序列。

注意，提交记录 C3 依然存在（树上那个半透明的节点），而 C3' 是我们 Rebase 到 main 分支上的 C3 的副本。

现在唯一的问题就是 main 还没有更新，下面咱们就来更新它。现在我们切换到了 `main` 上。把它 rebase 到 `bugFix` 分支

```sh
git rebase bugFix
```

<img src="/images/image-20220705191338505.png" alt="image-20220705191338505" style="zoom:67%;" />

由于 `bugFix` 继承自 `main`，所以 Git 只是简单的把 `main` 分支的引用向前移动了一下而已。

## 撤销

### 分离Head

通过`git checkout`

^

```sh
git checkout HEAD^^
```



~

```sh
git checkout HEAD~2
```

> HEAD处也可写成分支名，代表该分支最新的记录

### revert

创建一个相抵消的记录（可用于远程分支）

虽然在你的本地分支中使用 `git reset` 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的！

为了撤销更改并**分享**给别人，我们需要使用 `git revert`。

### reset

`git reset` 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。

`git reset` 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。

从提交记录中去除一个记录(不可用于远程分支)

> 在reset后， `C2` 所做的变更还在，但是处于未加入暂存区状态

![image-20220705190543250](/images/image-20220705190543250.png)

## 整理提交记录

### cherry-pick

```sh
git cherry-pick <提交号>...
```

如果你想将一些提交复制到当前所在的位置（`HEAD`）下面的话， Cherry-pick 是最直接的方式了。

与merge或者rebase这种处理整个分支所有变动的方法所不同的是，有时候，我们只需要部分代码变动（某几个提交），这时候可以采用cherry-pick。

依然举例说明：我们想将 `side` 分支上的工作复制到 `main` 分支

<img src="/images/image-20220705191743475.png" alt="image-20220705191743475" style="zoom:80%;" />

我们执行如下命令：

```sh
git cherry-pick C2 C4
```

我们只需要提交记录 `C2` 和 `C4`，所以 Git 就将被它们抓过来放到当前分支下了

<img src="/images/image-20220705191716810.png" alt="image-20220705191716810" style="zoom: 80%;" />

### 交互式rebase

当你知道你所需要的提交记录（**并且**还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。

但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase

交互式 rebase 指的是使用带参数 `--interactive` 的 rebase 命令, 简写为 `-i`

如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。

当 rebase UI界面打开时, 你能做3件事:

- 调整提交记录的顺序（通过鼠标拖放来完成）
- 删除你不想要的提交（通过切换 `pick` 的状态来完成，关闭就意味着你不想要这个提交记录）
- 合并提交。 遗憾的是由于某种逻辑的原因，我们的课程不支持此功能，因此我不会详细介绍这个操作。简而言之，它允许你把多个提交记录合并成一个。

## 合并提交记录



## 远程分支

我们可以使用git clone对远程仓库进行克隆，克隆完以后我们的本地仓库多了一个名为 `o/main` 的分支, 这种类型的分支就叫**远程**分支。由于远程分支的特性导致其拥有一些特殊属性。

远程分支反映了远程仓库(在你上次和它通信时)的**状态**。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.

远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。

这些远程分支的前面的 `o/` 是什么意思呢？远程分支有一个命名规范 —— 它们的格式是:

- `<remote name>/<branch name>`

因此，如果你看到一个名为 `o/main` 的分支，那么这个分支就叫 `main`，远程仓库的名称就是 `o`。

要记住, 当你使用真正的 Git 时, 你的远程仓库默认为 `origin`

如果我们checkout远程分支，并进行一个提交呢？

Git 变成了分离 HEAD 状态，当添加新的提交时 `o/main` 也不会更新。这是因为 `o/main` 只有在远程仓库中相应的分支更新了以后才会更新。

![image-20220705194727308](/images/image-20220705194727308.png)

```sh
git checkout o/main
git commit
```

<img src="/images/image-20220705194803349.png" alt="image-20220705194803349" style="zoom:67%;" />

### git fetch

Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。

本节课我们将学习如何从远程仓库获取数据 —— 命令如其名，它就是 `git fetch`。

`git fetch` 完成了仅有的但是很重要的两步:

- 从远程仓库下载本地仓库中缺失的提交记录
- 更新远程分支指针(如 `o/main`)

`git fetch` 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。

远程分支反映了远程仓库在你**最后一次与它通信时**的状态，`git fetch` 就是你与远程仓库通信的方式

#### git fetch不会改变本地仓库的状态

`git fetch` 并不会改变你本地仓库的状态。它不会更新你的 `main` 分支，也不会修改你磁盘上的文件。

理解这一点很重要，因为许多开发人员误以为执行了 `git fetch` 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是**并没有**修改你本地的文件。

所以, 你可以将 `git fetch` 的理解为单纯的下载操作。更新本地的

### git pull

既然我们已经知道了如何用 `git fetch` 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。

其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:

- `git cherry-pick o/main`
- `git rebase o/main`
- `git merge o/main`
- 等等

实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 `git pull`。